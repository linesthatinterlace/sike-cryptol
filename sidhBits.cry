module sidh32 where

////
//// "Small" SIDH Implementation
////

///
/// Initialization
///

//
// Parameters
//


//
// Starting Curve
//

startingCurve = { A = [0x00000006, 0x00000000], B = [0x00000001, 0x00000000]} : MontgomeryCurve

//
// Parameter sets
//

// p = 214990847
p = 0x0cd07fff
param_P2 = mkAffine [0x0a7e21eb, 0x09ab3afb] [0x0366529e, 0x00615a32]
param_Q2 = mkAffine [0x09875b2b, 0x076a3372] [0x00216b6b, 0x0b6465ec]
param_P3 = mkAffine [0x09aa9e25, 0x00000000] [0x040d8353, 0x00000000]
param_Q3 = mkAffine [0x0b96ade2, 0x00000000] [0x00000000, 0x082a1f97]


// 
// Data type conversions.
// 

ostofp : [4][8] -> [32]
ostofp xs = if (a >= p) then error "Octet string does not represent a member of F_p." else a
    where a = (reverse ~~> join) xs

fptoos : [32] -> [4][8]
fptoos = (\x -> x % p) ~~> split ~~> reverse

ostofp2 : [8][8] -> [2][32]
ostofp2 = split ~~> map ostofp

fp2toos : [2][32] -> [8][8]
fp2toos = map fptoos ~~> join

ostopk : [24][8] -> [3][2][32]
ostopk = split ~~> map ostofp2

pktoos : [3][2][32] -> [24][8]
pktoos = map fp2toos ~~> join

cast32To64 : [32] -> [64]
cast32To64 = zext

cast64To32 : [64] -> [32]
cast64To32 = drop

///
/// Finite Fields
///

//
// F_p
//
  

fpAdd : [32] -> [32] -> [32]
fpAdd a b = cast64To32 <~ (a' + b') % p'
    where   a' = cast32To64 a
            b' = cast32To64 b
            p' = cast32To64 p

fpAddInv : [32] -> [32]
fpAddInv a = if r == fpAddUnit then fpAddUnit else p - r
    where   r  = (a % p)

fpAddUnit : [32]
fpAddUnit = zero

fpMult : [32] -> [32] -> [32]
fpMult a b = cast64To32 <~ (a' * b') % p'
    where   a' = cast32To64 a
            b' = cast32To64 b
            p' = cast32To64 p

fpMultUnit : [32]
fpMultUnit = zero # 0b1

fpCmp : [32] -> [32] -> Bit
fpCmp a b = (a % p) == (b % p)

fpSubt : [32] -> [32] -> [32]
fpSubt a b = fpAdd a (fpAddInv b)

fpPow : [32] -> [32] -> [32]
fpPow a n = bs ! 0
    where   bs = [fpMultUnit] # [ if bit then fpMult a (fpSquare b) else fpSquare b | b <- bs | bit <- n ]

fpMultInv : [32] -> [32]
fpMultInv a =   if fpCmp a fpAddUnit
                then error "Cannot divide by zero!"
                else fpPow a ( p - 2 )
                

fpSquare : [32] -> [32]
fpSquare a = fpMult a a

fpSqrt : [32] -> [32]
fpSqrt a =  if ~(fpCmp (fpSquare r) a) then error "Not a quadratic residue in [32]!"
            else    if isEven r
                    then r
                    else fpAddInv r
            where   r   = fpPow a ( p + 1 >> 2 )

fpQuadNonRes : [32] -> Bit
fpQuadNonRes a = ~(fpCmp (fpSquare r) a)
    where r   = fpPow a ( p + 1 >> 2 )
    
isEven : [32] -> Bit
isEven x = ~(x ! 0)

//
// F_(p^2)
//

lift : [32] -> [2][32]
lift a = [a, fpAddUnit]

norm : [2][32] -> [32]
norm a = fpAdd (fpMult a0 a0) (fpMult a1 a1)
    where   [a0, a1]    = a

fp2Cmp : [2][32] -> [2][32] -> Bit
fp2Cmp [a0, a1] [b0, b1] = fpCmp a0 b0 /\ fpCmp a1 b1

fp2Add : [2][32] -> [2][32] -> [2][32]
fp2Add [a0, a1] [b0, b1] = [fpAdd a0 b0, fpAdd a1 b1]

fp2AddInv : [2][32] -> [2][32]
fp2AddInv  = map fpAddInv

fp2AddUnit : [2][32]
fp2AddUnit = lift fpAddUnit

fp2Subt : [2][32] -> [2][32] -> [2][32]
fp2Subt a b = fp2Add a (fp2AddInv b)

fp2Doub : [2][32] -> [2][32]
fp2Doub a = fp2Add a a

fp2Mult : [2][32] -> [2][32] -> [2][32]
fp2Mult [a0, a1] [b0, b1] = [fpSubt (fpMult a0 b0) (fpMult a1 b1), fpAdd (fpMult a0 b1) (fpMult a1 b0)]

fp2MultInv : [2][32] -> [2][32]
fp2MultInv [a0, a1] =   if fp2Cmp [a0, a1] fp2AddUnit
                        then error "Cannot divide by zero!"
                        else [fpMult a0 (fpMultInv (norm [a0, a1])), fpMult (fpAddInv a1) (fpMultInv (norm [a0, a1]))]

fp2MultUnit : [2][32]
fp2MultUnit = lift fpMultUnit

fp2Div : [2][32] -> [2][32] -> [2][32]
fp2Div a b = fp2Mult a (fp2MultInv b)

fp2Square : [2][32] -> [2][32]
fp2Square a = fp2Mult a a


fp2Sqrt : [2][32] -> [2][32]
fp2Sqrt a = if fpQuadNonRes (norm a)
            then error "Not a quadratic residue in [2][32]!"
            else
                if      fpCmp a1 fpAddUnit
                then    if      fpQuadNonRes a0
                        then    [fpAddUnit, fpSqrt (fpAddInv a0)]
                        else    [fpSqrt a0, fpAddUnit]
                else    if      (~isEven alpha)
                        then    fp2AddInv [alpha, beta]
                        else    [alpha, beta]
                where   [a0, a1]    = a
                        [alpha, beta]   =   if fpQuadNonRes z
                                            then [beta', fpAddInv alpha']
                                            else [alpha', beta']
                        inv2            =   fpMultInv 2
                        z               =   fpMult (fpAdd a0 (fpSqrt (norm a) ) ) inv2
                        alpha'          =   fpPow z ( p + 1 >> 2 )
                        beta'           =   fpMult (fpMult a1 (fpPow z ( p - 3 >> 2 )) ) inv2

fp2QuadNonRes : [2][32] -> Bit
fp2QuadNonRes = norm ~~> fpQuadNonRes


///
/// Curve Operations
///

//
// Elliptic Points and (Montgomery) curve data types.
//

type EllipticPoint = {x: [2][32], y: [2][32]}

mkAffine : [2][32] -> [2][32] -> EllipticPoint
mkAffine x' y' = {x = x', y = y'}

type MontgomeryCurve = { A: [2][32], B: [2][32]}

mkMC : [2][32] -> [2][32] -> MontgomeryCurve
mkMC a b = {A = a, B = b}

verifyCurve : MontgomeryCurve -> Bit
verifyCurve C = fp2Cmp discrim fp2AddUnit
    where   discrim = fp2Mult C.B (fp2Subt (fp2Square C.A) (fp2Doub ~~> fp2Doub <~ fp2MultUnit) )

pointAtInfinity : EllipticPoint
pointAtInfinity = mkAffine [0x00000000, 0x00000000] [0x00000001, 0x00000000]

isInfinite : EllipticPoint -> Bit
isInfinite P = (fp2Cmp P.x pointAtInfinity.x) /\ (fp2Cmp P.y pointAtInfinity.y)

verifyPoint : MontgomeryCurve -> EllipticPoint -> Bit
verifyPoint C P =  (isInfinite P) || (fp2Cmp LHS RHS)
                where   
                        yP      = P.y
                        yy      = fp2Square yP
                        LHS     = fp2Mult C.B yy
                        xx      = fp2Square xP
                        xP      = P.x
                        xxx     = fp2Mult xP xx
                        Axx     = fp2Mult C.A xx
                        RHS     = fp2Add (fp2Add xxx Axx) xP
                            

//
// Point and curve operations.
//

// Algorithm 25
xDBL : MontgomeryCurve -> EllipticPoint -> EllipticPoint
xDBL C P =  if isInfinite P
            then pointAtInfinity
            |  fp2Cmp P.y fp2AddUnit
            then pointAtInfinity
            else mkAffine x2P y2P
                where   xP  = P.x
                        yP  = P.y
                        t3  = fp2Square xP
                        t4  = fp2Doub t3
                        t5  = fp2MultUnit
                        t6  = fp2Add t3 t4
                        t7  = fp2Mult C.A xP
                        t8  = fp2Doub t7
                        t9  = fp2Add t6 t8
                        t10 = fp2Add t9 t5
                        t11 = fp2Mult C.B yP
                        t12 = fp2Doub t11
                        t13 = fp2MultInv t12
                        t14 = fp2Mult t10 t13
                        t15 = fp2Square t14
                        t16 = fp2Mult C.B t15
                        t17 = fp2Subt t16 C.A
                        t18 = fp2Subt t17 xP
                        t19 = fp2Subt t18 xP
                        t20 = fp2Mult t14 t15
                        t21 = fp2Mult C.B t20
                        t22 = fp2Add t21 yP
                        t23 = fp2Doub xP
                        t24 = fp2Add t23 xP
                        t25 = fp2Add t24 C.A
                        t26 = fp2Mult t25 t14
                        t27 = fp2Subt t26 t22
                        x2P = t19
                        y2P = t27

// Algorithm 26
xDBLe : {n} (fin n) => [n] -> MontgomeryCurve -> EllipticPoint -> EllipticPoint
xDBLe e C P = ys @ e
                where ys = iterate (xDBL C) P


// Algorithm 27
xADD : MontgomeryCurve -> EllipticPoint -> EllipticPoint -> EllipticPoint
xADD C P Q =    if isInfinite P
                then Q
                |  isInfinite Q
                then P
                | (fp2Cmp P.x Q.x) /\ (fp2Cmp P.y Q.y)
                then xDBL C P
                | (fp2Cmp P.x Q.x) /\ (fp2Cmp P.y (fp2AddInv Q.y))
                then pointAtInfinity
                else mkAffine xPQ yPQ
                    where   xP  = P.x
                            yP  = P.y
                            xQ  = Q.x
                            yQ  = Q.y
                            t9  = fp2Subt yQ yP
                            t10 = fp2Subt xQ xP
                            t11 = fp2MultInv t10
                            t12 = fp2Mult t9 t11
                            t13 = fp2Square t12
                            t14 = fp2Doub xP
                            t15 = fp2Add t14 xQ
                            t16 = fp2Add t15 C.A
                            t17 = fp2Mult t16 t12
                            t18 = fp2Mult t12 t13
                            t19 = fp2Mult C.B t18
                            t20 = fp2Add t19 yP
                            t21 = fp2Subt t17 t20
                            t22 = fp2Mult C.B t13
                            t23 = fp2Subt t22 C.A
                            t24 = fp2Subt t23 xP
                            t25 = fp2Subt t24 xQ
                            xPQ = t25
                            yPQ = t21



// Algorithm 28
xTPL : MontgomeryCurve -> EllipticPoint -> EllipticPoint
xTPL C P = xADD C P (xDBL C P)

// Algorithm 29
xTPLe : {n} (fin n) => [n] -> MontgomeryCurve -> EllipticPoint -> EllipticPoint
xTPLe e C P  = ys @ e
                where ys = iterate (xTPL C) P

// Algorithm 30
double_and_add : {n} (fin n) => MontgomeryCurve -> EllipticPoint -> [n] -> EllipticPoint
double_and_add C P n = bs ! 0
                        where bs = [pointAtInfinity] # [ if bit then xADD C P (xDBL C b) else xDBL C b | b <- bs | bit <- n ]

// Algorithm 31
j_inv : MontgomeryCurve ->  [2][32]
j_inv C = j
    where   t1  = fp2Square C.A
            t2  = fp2Add (fp2Doub fp2MultUnit) fp2MultUnit
            t3  = fp2Subt t1 t2
            t4  = fp2Square t3
            t5  = fp2Mult t3 t4
            t6  = fp2Doub t5
            t7  = fp2Doub t6
            t8  = fp2Doub t7
            t9  = fp2Doub t8
            t10 = fp2Doub t9
            t11 = fp2Doub t10
            t12 = fp2Doub t11
            t13 = fp2Doub t12
            t14 = fp2Doub ~~> fp2Doub <~ fp2MultUnit
            t15 = fp2Subt t1 t14
            t16 = fp2MultInv t15
            t17 = fp2Mult t13 t16
            j   = t17

//
// Isogenies.
//

// Algorithm 32
curve_2_iso : EllipticPoint -> MontgomeryCurve -> MontgomeryCurve
curve_2_iso T C = {A = a', B = b'}
    where   t1  = fp2Square T.x
            t2  = fp2Doub t1
            t3  = fp2Subt fp2MultUnit t2
            t4  = fp2Doub t3
            t5  = fp2Mult T.x C.B
            a'  = t4
            b'  = t5
                            
// a' = 2*(1-2*x2^2)
// b' = x2*b
          
         
// Algorithm 33
eval_2_iso : EllipticPoint -> EllipticPoint -> EllipticPoint
eval_2_iso T Q = Q'
    where   (xQ, yQ) = (Q.x, Q.y)
            t1  = fp2Mult xQ T.x
            t2  = fp2Mult xQ t1
            t3  = fp2Mult t1 T.x
            t4  = fp2Doub t3
            t5  = fp2Subt t2 t4
            t6  = fp2Add t5 T.x
            t7  = fp2Mult yQ t6
            t8  = fp2Subt t2 xQ
            t9  = fp2Subt xQ T.x
            t10 = fp2MultInv t9
            t11 = fp2Mult t8 t10
            t12 = fp2Square t10
            t13 = fp2Mult t7 t12
            xQ' = t11
            yQ' = t13
            Q'  = mkAffine xQ' yQ'

// xQ':=(xQ^2*x2-xQ)/(xQ-x2);
// yQ':=yQ*(xQ^2*x2-2*xQ*x2^2+x2)/(xQ-x2)^2;

// Algorithm 34
curve_4_iso : EllipticPoint -> MontgomeryCurve -> MontgomeryCurve
curve_4_iso T C = {A = a', B = b'}
    where   t1  = fp2Square T.x
            t2  = fp2Square t1
            t3  = fp2Doub t2
            t4  = fp2Doub t3
            t5  = fp2Doub fp2MultUnit
            t6  = fp2Subt t4 t5
            t7  = fp2Mult T.x t1
            t8  = fp2Add t7 T.x
            t9  = fp2Mult t8 C.B
            t10 = fp2MultInv t5
            t11 = fp2AddInv t10
            t12 = fp2Mult t11 t9
            a'  = t6
            b'  = t12

// a':=4*x4^4-2;
// b':== -(1/2)*(x4^3+x4)*b;

// Algorithm 35
eval_4_iso : EllipticPoint -> EllipticPoint -> EllipticPoint
eval_4_iso T Q = Q'
    where   (xQ, yQ) = (Q.x, Q.y)
            t1  = fp2Square xQ
            t2  = fp2Square t1
            t3  = fp2Square T.x
            t4  = fp2Mult t2 t3
            t5  = fp2Add t2 t4
            t6  = fp2Mult t1 t3
            t7  = fp2Doub t6
            t8  = fp2Doub t7
            t9  = fp2Doub t8
            t10 = fp2Add t7 t9
            t11 = fp2Add t5 t10
            t12 = fp2Square t3
            t13 = fp2Mult t1 t12
            t14 = fp2Doub t13
            t15 = fp2Add t11 t14
            t16 = fp2Mult t1 xQ
            t17 = fp2Mult T.x t3
            t18 = fp2Mult t16 t17
            t19 = fp2Doub t18
            t20 = fp2Doub t19
            t21 = fp2Subt t15 t20
            t22 = fp2Mult t16 T.x 
            t23 = fp2Doub t22
            t24 = fp2Doub t23
            t25 = fp2Subt t21 t24
            t26 = fp2Mult xQ t17
            t27 = fp2Doub t26
            t28 = fp2Doub t27
            t29 = fp2Subt t25 t28
            t30 = fp2Add t29 t3
            t31 = fp2Add t30 fp2MultUnit
            t32 = fp2Mult xQ T.x
            t33 = fp2Subt t32 fp2MultUnit
            t34 = fp2Doub t32
            t35 = fp2Doub t34
            t36 = fp2Subt t31 t35
            t37 = fp2Mult t33 t36
            t38 = fp2Mult t3 t37
            t39 = fp2Mult yQ t38
            t40 = fp2Doub t39
            t41 = fp2AddInv t40
            t42 = fp2Subt t34 t3
            t43 = fp2Subt t42 fp2MultUnit
            t44 = fp2Subt xQ T.x
            t45 = fp2Mult t44 t43
            t46 = fp2Square t45
            t47 = fp2Mult t46 t44
            t48 = fp2MultInv t47
            t49 = fp2Mult t41 t48
            t50 = fp2Mult t45 t44
            t51 = fp2MultInv t50
            t52 = fp2Square t33
            t53 = fp2Mult t51 t52
            t54 = fp2Mult xQ t53
            t55 = fp2Mult xQ t3
            t56 = fp2Add t55 xQ
            t57 = fp2Doub T.x
            t58 = fp2Subt t56 t57
            t59 = fp2AddInv t58
            t60 = fp2Mult t54 t59
            xQ' = t60
            yQ' = t49
            Q'  = mkAffine xQ' yQ'

// xx:=x(-x*x4^2-x+2*x4)*C*C/(B*B*A);
// yy:=y*x4^2*C*D/(B*B*B*A*A);

// Algorithm 36
curve_3_iso : EllipticPoint -> MontgomeryCurve -> MontgomeryCurve
curve_3_iso T C = {A = a', B = b'}
    where   t1  = fp2Square T.x
            t2  = fp2Mult C.B t1
            t3  = fp2Doub t1
            t4  = fp2Doub t3
            t5  = fp2Add t3 t4
            t6  = fp2Doub <~ fp2Add (fp2Doub fp2MultUnit) fp2MultUnit
            t7  = fp2Subt t5 t6
            t8  = fp2Mult C.A T.x
            t9  = fp2Subt t8 t7
            t10 = fp2Mult t9 T.x
            a'  = t10
            b'  = t2

// a':=(a*x3-6*x3^2+6)*x3;
// b':=b*x3^2;

// Algorithm 37
eval_3_iso : EllipticPoint -> EllipticPoint -> EllipticPoint
eval_3_iso T Q = Q'
    where   x3  = T.x
            (xQ, yQ) = (Q.x, Q.y)
            t1  = fp2Square xQ
            t2  = fp2Mult t1 T.x
            t3  = fp2Square T.x
            t4  = fp2Mult xQ t3
            t5  = fp2Doub t4
            t6  = fp2Add t4 t5
            t7  = fp2Subt t2 t6
            t8  = fp2Add t7 xQ
            t9  = fp2Add t8 T.x
            t10 = fp2Subt xQ T.x
            t11 = fp2MultInv t10
            t12 = fp2Square t11
            t13 = fp2Mult t11 t12
            t14 = fp2Mult xQ T.x
            t15 = fp2Subt t14 fp2MultUnit
            t16 = fp2Mult t15 t9
            t17 = fp2Mult t16 t13
            t18 = fp2Square t15
            t19 = fp2Mult t18 t12
            t20 = fp2Mult xQ t19
            t21 = fp2Mult yQ t17
            xQ' = t20
            yQ' = t21
            Q'  = mkAffine xQ' yQ'

// xQ':=xQ*(xQ*x3-1)^2/(xQ-x3)^2;
// yQ':=yQ*(xQ*x3-1)*(xQ^2*x3-3*xQ*x3^2+xQ+x3)/(xQ-x3)^3;

// Algorithm 38
iso_2_e : {e, n} (fin e, e >= 4, fin n) => EllipticPoint -> (MontgomeryCurve, [n]EllipticPoint) -> (MontgomeryCurve, [n]EllipticPoint)
iso_2_e S' (C', Ps') = (C'', Ps'')
    where   init = {S = S', C = C', Ps = Ps'}
            init' = if (`e ) % (2 : [width e]) == 0 then init else iso_2_e_odd_step`{width e} (`e - 1) init
            ms = reverse [0, 2 .. e - 2]
            ys = [init'] # [ iso_2_e_step`{width e} m y | m <- ms | y <- ys ]
            final_y = ys ! 0
            (C'', Ps'') = (final_y.C, final_y.Ps)

iso_2_e_odd_step : {m, n} (fin m, fin n) => [m] -> {S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint} -> { S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint }
iso_2_e_odd_step k y = {S = S', C = C', Ps = Ps'}
    where   T   = xDBLe k y.C y.S
            S'  = eval_2_iso T y.S
            C'  = curve_2_iso T y.C
            Ps' = map (eval_2_iso T) y.Ps

iso_2_e_step : {m, n} (fin m, fin n) => [m] -> {S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint} -> { S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint }
iso_2_e_step k y = {S = S', C = C', Ps = Ps'}
    where   T   = xDBLe k y.C y.S
            S'  = eval_4_iso T y.S
            C'  = curve_4_iso T y.C
            Ps' = map (eval_4_iso T) y.Ps

// Algorithm 39
iso_3_e : {e, n} (fin e, e >= 1, fin n) => EllipticPoint -> (MontgomeryCurve, [n]EllipticPoint) -> (MontgomeryCurve, [n]EllipticPoint)
iso_3_e S' (C', Ps') = (C'', Ps'')
    where   init = {S = S', C = C', Ps = Ps'}
            ms = reverse [0 .. e - 1]
            ys = [init] # [ iso_3_e_step`{width e} m y | m <- ms | y <- ys ]
            final_y = ys ! 0
            (C'', Ps'') = (final_y.C, final_y.Ps)

iso_3_e_step : {m, n} (fin m, fin n) => [m] -> {S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint} -> { S: EllipticPoint, C: MontgomeryCurve, Ps: [n]EllipticPoint }
iso_3_e_step k y = {S = S', C = C', Ps = Ps'}
    where   T = xTPLe k y.C y.S
            S' = eval_3_iso T y.S
            C' = curve_3_iso T y.C
            Ps' = map (eval_3_iso T) y.Ps

// Algorithm 10
get_A : [3][2][32] -> [2][32]
get_A [xP, xQ, xR] = A
    where   t1  = fp2Add xP xQ
            t2  = fp2Mult xP xQ
            t3  = fp2Mult xR t1
            t4  = fp2Add t3 t2
            t5  = fp2Mult t2 xR
            t6  = fp2Subt t4 fp2MultUnit
            t7  = fp2Doub t5
            t8  = fp2Add t1 xR
            t9  = fp2Doub t7
            t10 = fp2Square t6
            t11 = fp2MultInv t9
            t12 = fp2Mult t10 t11
            t13 = fp2Subt t12 t8
            A   = t13

// Algorithm 40
get_xR : MontgomeryCurve -> EllipticPoint -> EllipticPoint -> [2][32]
get_xR C P Q = (xADD C P (mkAffine Q.x (fp2AddInv Q.y))).x

// Algorithm 41
get_yP_yQ_A_B : [24][8] -> (EllipticPoint, EllipticPoint, MontgomeryCurve)
get_yP_yQ_A_B pk = (P, Q, C)
    where   [xP, xQ, xR] = ostopk pk
            t1  = get_A [xP, xQ, xR]
            t2  = fp2MultUnit
            t3  = fp2Square xP
            t4  = fp2Mult xP t3
            t5  = fp2Mult t1 t3
            t6  = fp2Add t4 t5
            t7  = fp2Add t6 xP
            t8  = fp2Sqrt t7
            t9  = fp2Square xQ
            t10 = fp2Mult xQ t9
            t11 = fp2Mult t1 t9
            t12 = fp2Add t10 t11
            t13 = fp2Add t12 xQ
            t14 = fp2Sqrt t13        
            yP  = t8
            yQ  = t14
            C   = mkMC t1 t2
            P   = mkAffine xP yP
            Q   = mkAffine xQ yQ
            yQ' = if ~( fp2Cmp (get_xR C P Q) xR ) then fp2AddInv yQ else yQ

//
// isogen_l and isoex_l for l in {2, 3}
//

// Algorithm 42
isogen_2 : [2][8] -> [24][8]
isogen_2 sk2 = pk2
    where   exponent = (reverse ~~> join) sk2
            S = xADD startingCurve param_P2 (double_and_add startingCurve param_Q2 exponent )
            (C, [P3', Q3']) = iso_2_e`{15} S (startingCurve, [param_P3, param_Q3])
            xP3' = P3'.x
            xQ3' = Q3'.x
            xR3' = get_xR C P3' Q3'
            pk2 = pktoos [xP3', xQ3', xR3']

// Algorithm 43
isogen_3 : [2][8] -> [24][8]
isogen_3 sk3 = pk3
    where   exponent = (reverse ~~> join) sk3
            S = xADD startingCurve param_P3 (double_and_add startingCurve param_Q3 exponent)
            (C, [P2', Q2']) = iso_3_e`{8} S (startingCurve, [param_P2, param_Q2])
            xP2' = P2'.x
            xQ2' = Q2'.x
            xR2' = get_xR C P2' Q2'
            pk3 = pktoos [xP2', xQ2', xR2']

// Algorithm 44
isoex_2 : [24][8] -> [2][8] -> [8][8]
isoex_2 pk3 sk2 = j2
    where   exponent = (reverse ~~> join) sk2
            [xP2', xQ2', xR2'] = ostopk pk3
            (P2', Q2', C) = get_yP_yQ_A_B pk3
            S = xADD C P2' (double_and_add C Q2' exponent)
            (C', _) = iso_2_e`{15} S (C, [])
            j2 = fp2toos <~ j_inv C'


// Algorithm 45
isoex_3 : [24][8] -> [2][8] -> [8][8]
isoex_3 pk2 sk3 = j3
    where   exponent = (reverse ~~> join) sk3
            [xP3', xQ3', xR3'] = ostopk pk2
            (P3', Q3', C) = get_yP_yQ_A_B pk2
            S = xADD C P3' (double_and_add C Q3' exponent)
            (C', _) = iso_3_e`{8} S (C, [])
            j3 = fp2toos <~ j_inv C'


isogenWork: ([2][8], [2][8]) -> Bool
isogenWork (secretKeyAlice, secretKeyBob) = sharedSecretAlice == sharedSecretBob
    where
        publicKeyAlice      = isogen_2 secretKeyAlice
        publicKeyBob        = isogen_3 secretKeyBob
        sharedSecretAlice   = isoex_2 publicKeyBob secretKeyAlice
        sharedSecretBob     = isoex_3 publicKeyAlice secretKeyBob

property secretShared [a0, a1, b0, b1] = isoex_3 (isogen_2 [a0, a1]) [b0, b1] == isoex_2 (isogen_3 [b0, b1]) [a0, a1]

///
/// Tests
///

//
// F_p Arithmetic Tests
//

property fpAddAssociative a b c = fpCmp ( fpAdd a ( fpAdd b c ) ) ( fpAdd ( fpAdd a b ) c )
property fpAddCommutative a b = fpCmp ( fpAdd a b ) ( fpAdd b a )
property fpAddZeroIdentity a = fpCmp (fpAdd a fpAddUnit ) a
property fpAddValidInverse a = fpCmp ( fpAdd a (fpAddInv a) ) ( fpAddUnit )
property fpSubtOrderOfOps a b c = fpCmp ( fpSubt (fpSubt a b) c ) ( fpSubt a (fpAdd b c) )
property fpSubtAnticommutative a b = fpCmp ( fpSubt a b ) ( fpAddInv (fpSubt b a) )
property fpSubtZeroIdentity a = fpCmp ( fpSubt a fpAddUnit ) a
property fpMultAssociative a b c = fpCmp ( fpMult a ( fpMult b c ) ) ( fpMult ( fpMult a b ) c )
property fpMultDistributive a b c = fpCmp ( fpMult a (fpAdd b c) ) ( fpAdd (fpMult a b) (fpMult a c) )
property fpMultCommutative a b = fpCmp ( fpMult a b ) ( fpMult b a )
property fpMultOneIdentity a = fpCmp ( fpMult a fpMultUnit ) a
property fpMultZeroNull a = fpCmp ( fpMult a fpAddUnit ) fpAddUnit
property fpSquareIsMult a = fpCmp ( fpSquare a ) ( fpMult a a )
property fpAddInvSquareSelf = fpCmp ( fpSquare fpAddUnit ) fpAddUnit
property fpMultValidInverse a = fpCmp a fpAddUnit \/ fpCmp ( fpMult a (fpMultInv a) ) fpMultUnit
property fpMultInverseInverseIdentity a = fpCmp a fpAddUnit \/ fpCmp ( fpMultInv (fpMultInv a) ) a
property fpSquareSqrtIdentity a = fpQuadNonRes a \/ fpCmp ( (fpSqrt ~~> fpSquare) a ) a
property fpSqrtSquareIdentity a = fpCmp ( (fpSquare ~~> fpSqrt) a ) a \/ fpCmp ( (fpSquare ~~> fpSqrt) a ) ( fpAddInv a )

//
// F_(p^2) Arithmetic Tests
//

property fp2AddAssociative a b c = fp2Cmp ( fp2Add a ( fp2Add b c ) ) ( fp2Add ( fp2Add a b ) c )
property fp2AddCommutative a b = fp2Cmp ( fp2Add a b ) ( fp2Add b a )
property fp2AddZeroIdentity a = fp2Cmp ( fp2Add a fp2AddUnit ) a
property fp2AddValidInverse a = fp2Cmp ( fp2Add a (fp2AddInv a) ) fp2AddUnit
property fp2SubtOrderOfOps a b c = fp2Cmp ( fp2Subt (fp2Subt a b) c ) ( fp2Subt a (fp2Add b c) )
property fp2SubtAnticommutative a b = fp2Cmp ( fp2Subt a b ) ( fp2AddInv (fp2Subt b a) )
property fp2SubtZeroIdentity a = fp2Cmp ( fp2Subt a fp2AddUnit ) a
property fp2MultAssociative a b c = fp2Cmp ( fp2Mult a ( fp2Mult b c ) ) ( fp2Mult ( fp2Mult a b ) c )
property fp2MultDistributive a b c = fp2Cmp ( fp2Mult a (fp2Add b c) ) ( fp2Add (fp2Mult a b) (fp2Mult a c) )
property fp2MultCommutative a b = fp2Cmp ( fp2Mult a b ) ( fp2Mult b a )
property fp2MultOneIdentity a = fp2Cmp ( fp2Mult a fp2MultUnit ) a
property fp2MultZeroNull a = fp2Cmp ( fp2Mult a fp2AddUnit ) fp2AddUnit
property fp2SquareIsMult a = fp2Cmp ( fp2Square a ) ( fp2Mult a a )
property fp2AddInvSquareSelf = fp2Cmp ( fp2Square fp2AddUnit ) fp2AddUnit
property fp2MultValidInverse a = fp2Cmp a fp2AddUnit \/ fp2Cmp ( fp2Mult a (fp2MultInv a) ) fp2MultUnit
property fp2MultInverseInverseIdentity a = fp2Cmp a fp2AddUnit \/ fp2Cmp ( fp2MultInv (fp2MultInv a) ) a
property fp2SquareSqrtIdentity a = fp2QuadNonRes a \/ fp2Cmp ( (fp2Sqrt ~~> fp2Square) a ) a
property fp2SqrtSquareIdentity a = fp2Cmp ( (fp2Square ~~> fp2Sqrt) a ) a \/ fp2Cmp ( (fp2Square ~~> fp2Sqrt) a ) ( fp2AddInv a )


///
/// Miscellaneous
///

//
// Functional programming operators.
//

(~~>) : {a, b, c} (a -> b) -> (b -> c) -> a -> c
(~~>) f g = \x -> g (f x)
infixr 100 ~~>

(<~) : {a, b} (a -> b) -> a -> b
(<~) f x = f x
infixr 1 <~
